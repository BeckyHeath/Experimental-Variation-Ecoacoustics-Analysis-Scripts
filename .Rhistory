}
}
}
# Final labels.
legend('bottomright', col=1:4, legend=c("20 min", "10 min", "5 min", "2.5 min"),
bty='n', lty=1)
mtext(side=2, 'Accuracy', outer=TRUE, line=2.2)
mtext(side=1, expression(log[10]~file~size), outer=TRUE, line=2.2)
hexplot <- hexbinplot(precision_t ~ log10(file.size) | index.type + chunks,
aspect=2/3, data=dat, colorkey=FALSE)
hexplot <- useOuterStrips(hexplot)
print(hexplot)
options(repr.plot.width = 6, repr.plot.height = 8)
# Create a 4 by 2 layout of edge to edge plots with
# an outer margin for annotation
par(mfcol=c(4,2), mar=c(0,0,0,0), oma=c(4,4,2.2,2.2), mgp=c(1.8,0.6, 0))
# Loop combinations of index type (columns) and chunking (rows)
for (it in 1:2){
for (ch in 1:4){
this_it <- levels(dat$index.type)[it]
this_ch <- levels(dat$chunks)[ch]
# Get a hexbin object for this panel subset
dd <- subset(dat, index.type == this_it & chunks == this_ch)
hx <- hexbin(log10(dd$file.size), dd$precision_t, xbins=30,
shape=2/3, xbnds=c(0,2), ybnds=c(0.2,1))
# Convert the hexbin of the data to base graphics
hx_p <- hexbin_to_poly(hx)
plot(hx_p, type='n', xaxt='n', yaxt='n', xlim=c(0,2), ylim=c(0.2,1))
# Colour scale for density (relative within plots)
cols <- (1 - (hx@count / max(hx@count)) * 0.7) - 0.2
# Add polygons
polygon(hx_p, col=grey(cols), border=NA)
# Add prediction lines for the four frame size fits
for (fs in 1:4){
this_fs <- levels(dat$frame.size)[fs]
fit <- subset(pred, index.type == this_it & chunks == this_ch & frame.size == this_fs)
lines(fit_acc ~ log10(file.size), data=fit, col=fs)
}
# Conditional panel annotation.
if (it == 1) axis(2, at=seq(0.25, 1, by=0.25))
if (ch == 4) axis(1)
if (ch == 1) {
axis(3, labels=FALSE, at=seq(0.25, 1, by=0.25))
mtext(side=3, this_it, line=1)
}
if (it == 2){
axis(4, labels=FALSE)
mtext(side=4, this_ch, line=1)
}
}
}
pred$fit_acc <- predict(mod_br_phi, newdata=pred)
pred_plot_acc <- xyplot(fit_acc ~ log10(file.size) | index.type + chunks, group= frame.size,
data=pred, type='l', key=key,
scales=list(alternating=FALSE, y=list(lim=c(0.65,1.05), at=c(0.7,0.8,0.9,1.0))),
ylab='Predicted accuracy', main='Accuracy')
pred_plot_acc <- useOuterStrips(pred_plot_acc)
# Combine
options(repr.plot.width = 15, repr.plot.height = 6)
print(pred_plot_acc, split=c(1,1,3,1), more=TRUE)
print(pred_plot_prec, split=c(2,1,3,1), more=TRUE)
print(pred_plot_recall, split=c(3,1,3,1), more=FALSE)
hexplot <- hexbinplot(accuracy_t ~ log10(file.size) | index.type + chunks,
aspect=2/3, data=dat, colorkey=FALSE)
hexplot <- useOuterStrips(hexplot)
print(hexplot)
View(pred)
pred$prec_fit <- predict(mod_br_phi, newdata=pred)
pred_plot_acc <- xyplot(prec_fit ~ log10(file.size) | index.type + chunks, group= frame.size,
data=pred, type='l', key=key,
scales=list(alternating=FALSE, y=list(lim=c(0.65,1.05), at=c(0.7,0.8,0.9,1.0))),
ylab='Predicted Precision', main='Precision')
pred_plot_acc <- useOuterStrips(pred_plot_acc)
hexplot <- hexbinplot(precision_t ~ log10(file.size) | index.type + chunks,
aspect=2/3, data=dat, colorkey=FALSE)
hexplot <- useOuterStrips(hexplot)
print(hexplot)
options(repr.plot.width = 6, repr.plot.height = 8)
# Create a 4 by 2 layout of edge to edge plots with
# an outer margin for annotation
par(mfcol=c(4,2), mar=c(0,0,0,0), oma=c(4,4,2.2,2.2), mgp=c(1.8,0.6, 0))
# Loop combinations of index type (columns) and chunking (rows)
for (it in 1:2){
for (ch in 1:4){
this_it <- levels(dat$index.type)[it]
this_ch <- levels(dat$chunks)[ch]
# Get a hexbin object for this panel subset
dd <- subset(dat, index.type == this_it & chunks == this_ch)
hx <- hexbin(log10(dd$file.size), dd$precision_t, xbins=30,
shape=2/3, xbnds=c(0,2), ybnds=c(0.2,1))
# Convert the hexbin of the data to base graphics
hx_p <- hexbin_to_poly(hx)
plot(hx_p, type='n', xaxt='n', yaxt='n', xlim=c(0,2), ylim=c(0.2,1))
# Colour scale for density (relative within plots)
cols <- (1 - (hx@count / max(hx@count)) * 0.7) - 0.2
# Add polygons
polygon(hx_p, col=grey(cols), border=NA)
# Add prediction lines for the four frame size fits
for (fs in 1:4){
this_fs <- levels(dat$frame.size)[fs]
fit <- subset(pred, index.type == this_it & chunks == this_ch & frame.size == this_fs)
lines(fit_acc ~ log10(file.size), data=fit, col=fs)
}
# Conditional panel annotation.
if (it == 1) axis(2, at=seq(0.25, 1, by=0.25))
if (ch == 4) axis(1)
if (ch == 1) {
axis(3, labels=FALSE, at=seq(0.25, 1, by=0.25))
mtext(side=3, this_it, line=1)
}
if (it == 2){
axis(4, labels=FALSE)
mtext(side=4, this_ch, line=1)
}
}
}
print(pred_plot_prec, split=c(2,1,3,1), more=TRUE)
# Final labels.
legend('bottomright', col=1:4, legend=c("20 min", "10 min", "5 min", "2.5 min"),
bty='n', lty=1)
mtext(side=2, 'Accuracy', outer=TRUE, line=2.2)
mtext(side=1, expression(log[10]~file~size), outer=TRUE, line=2.2)
hexplot <- hexbinplot(precision_t ~ log10(file.size) | index.type + chunks,
aspect=2/3, data=dat, colorkey=FALSE)
hexplot <- useOuterStrips(hexplot)
print(hexplot)
options(repr.plot.width = 6, repr.plot.height = 8)
# Create a 4 by 2 layout of edge to edge plots with
# an outer margin for annotation
par(mfcol=c(4,2), mar=c(0,0,0,0), oma=c(4,4,2.2,2.2), mgp=c(1.8,0.6, 0))
# Loop combinations of index type (columns) and chunking (rows)
for (it in 1:2){
for (ch in 1:4){
this_it <- levels(dat$index.type)[it]
this_ch <- levels(dat$chunks)[ch]
# Get a hexbin object for this panel subset
dd <- subset(dat, index.type == this_it & chunks == this_ch)
hx <- hexbin(log10(dd$file.size), dd$precision_t, xbins=30,
shape=2/3, xbnds=c(0,2), ybnds=c(0.2,1))
# Convert the hexbin of the data to base graphics
hx_p <- hexbin_to_poly(hx)
plot(hx_p, type='n', xaxt='n', yaxt='n', xlim=c(0,2), ylim=c(0.2,1))
# Colour scale for density (relative within plots)
cols <- (1 - (hx@count / max(hx@count)) * 0.7) - 0.2
# Add polygons
polygon(hx_p, col=grey(cols), border=NA)
# Add prediction lines for the four frame size fits
for (fs in 1:4){
this_fs <- levels(dat$frame.size)[fs]
fit <- subset(pred, index.type == this_it & chunks == this_ch & frame.size == this_fs)
lines(prec_fit ~ log10(file.size), data=fit, col=fs)
}
# Conditional panel annotation.
if (it == 1) axis(2, at=seq(0.25, 1, by=0.25))
if (ch == 4) axis(1)
if (ch == 1) {
axis(3, labels=FALSE, at=seq(0.25, 1, by=0.25))
mtext(side=3, this_it, line=1)
}
if (it == 2){
axis(4, labels=FALSE)
mtext(side=4, this_ch, line=1)
}
}
}
# Final labels.
legend('bottomright', col=1:4, legend=c("20 min", "10 min", "5 min", "2.5 min"),
bty='n', lty=1)
mtext(side=2, 'Precision', outer=TRUE, line=2.2)
mtext(side=1, expression(log[10]~file~size), outer=TRUE, line=2.2)
View(dd)
hx <- hexbin(log10(dd$file.size), dd$precision_t, xbins=30,
shape=2/3, xbnds=c(0,2), ybnds=c(0.2,1))
dat$precision_t <- (dat$precision * (n - 1) + 0.5) / n
mod_br_phi_prec <- update(mod_br_phi, precision_t ~ ., subset = ! is.na(precision_t))
# Plot them
pred$prec_fit <- predict(mod_br_phi_prec, newdata=pred)
pred_plot_prec <- xyplot(prec_fit ~ log10(file.size) | index.type + chunks, group= frame.size,
data=pred, type='l', key=key,,
scales=list(alternating=FALSE, y=list(lim=c(0.65,1.05), at=c(0.7,0.8,0.9,1.0))),
ylab='Predicted precision', main='Precision')
pred_plot_prec <- xyplot(prec_fit ~ log10(file.size) | index.type + chunks, group= frame.size,
data=pred, type='l', key=key,
scales=list(alternating=FALSE, y=list(lim=c(0.65,1.05), at=c(0.7,0.8,0.9,1.0))),
ylab='Predicted precision', main='Precision')
pred_plot_prec <- useOuterStrips(pred_plot_prec)
dat <- accuracy.both
# Sensible orders for factors
dat$frame.size <- factor(dat$frame.size, levels=c("20min", "10min", "5min", "2_5min"))
dat$chunks <- factor(dat$chunks, levels=c("None", "4", "8", "12"))
# Correction to allow betaregression [0,1] to (0,1)
# Note: this reduces 100% values to 99.94% ((100*1799)+0.5)/1800
n <- nrow(dat)
dat$accuracy_t <- (dat$accuracy * (n - 1) + 0.5) / n
dat$precision_t <- (dat$precision * (n - 1) + 0.5) / n
dat$recall_t <- (dat$recall * (n - 1) + 0.5) / n
dat <- dat[complete.cases(dat),]
# Maximum Models (fully iteracted and substitute)
max_model <- accuracy_t ~ (log10(file.size) + chunks + frame.size) ^ 2 * index.type
max_model <- precision_t ~ (log10(file.size) + chunks + frame.size) ^ 2 * index.type
max_model <- recall_t ~ (log10(file.size) + chunks + frame.size) ^ 2 * index.type
# Linear Model (as in early analysis)
mod_lm <- lm(max_model, data= dat)
summary.aov(mod_lm)
# Betareg Model
mod_br <- betareg(max_model, data=dat)
# Looking at Variation:
var_plot <- bwplot(accuracy ~ frame.size | index.type + chunks, data=dat)
var_plot <- useOuterStrips(var_plot)
print(var_plot)
mod_br_phi <- update(mod_br,  . ~ .  | index.type * chunks)
summary(mod_br_phi)
AIC(mod_lm, mod_br, mod_br_phi) # shows this model is best
aov_table <- Anova(mod_br_phi)
aov_table
dat$index.type <- as.factor(dat$index.type)
# Create a range of values to predict
pred <- expand.grid(file.size = 10 ^ seq(0, 2, length=31),
index.type = levels(dat$index.type),
chunks = levels(dat$chunks),
frame.size = levels(dat$frame.size))
# Create the predictions
pred$fit_acc <- predict(mod_br_phi, newdata=pred)
# Plot them
key <- list(corner=c(0.98, 0.03),
lines=list(col=trellis.par.get('superpose.line')$col[1:4]),
text=list(c("20 min", "10 min", "5 min", "2.5 min"), cex=0.7))
pred_plot_acc <- xyplot(fit_acc ~ log10(file.size) | index.type + chunks, group= frame.size,
data=pred, type='l', key=key)
pred_plot_acc <- useOuterStrips(pred_plot_acc)
print(pred_plot_acc)
dat$precision_t <- (dat$precision * (n - 1) + 0.5) / n
mod_br_phi_prec <- update(mod_br_phi, precision_t ~ ., subset = ! is.na(precision_t))
# Plot them
pred$prec_fit <- predict(mod_br_phi_prec, newdata=pred)
pred_plot_prec <- xyplot(prec_fit ~ log10(file.size) | index.type + chunks, group= frame.size,
data=pred, type='l', key=key,
scales=list(alternating=FALSE, y=list(lim=c(0.65,1.05), at=c(0.7,0.8,0.9,1.0))),
ylab='Predicted precision', main='Precision')
pred_plot_prec <- useOuterStrips(pred_plot_prec)
print(pred_plot_prec)
dat$recall_t <- (dat$recall * (n - 1) + 0.5) / n
mod_br_phi_recall <- update(mod_br_phi, recall_t ~ .)
pred$recall_fit <- predict(mod_br_phi_recall, newdata=pred)
# Plot them
pred_plot_recall <- xyplot(recall_fit ~ log10(file.size) | index.type + chunks, group= frame.size,
data=pred, type='l', key=key,
scales=list(alternating=FALSE, y=list(lim=c(0.65,1.05), at=c(0.7,0.8,0.9,1.0))),
ylab='Predicted recall', main='Recall')
pred_plot_recall <- useOuterStrips(pred_plot_recall)
print(pred_plot_recall)
pred$fit_acc <- predict(mod_br_phi, newdata=pred)
pred_plot_acc <- xyplot(fit_acc ~ log10(file.size) | index.type + chunks, group= frame.size,
data=pred, type='l', key=key,
scales=list(alternating=FALSE, y=list(lim=c(0.65,1.05), at=c(0.7,0.8,0.9,1.0))),
ylab='Predicted accuracy', main='Accuracy')
pred_plot_acc <- useOuterStrips(pred_plot_acc)
# Combine
options(repr.plot.width = 15, repr.plot.height = 6)
print(pred_plot_acc, split=c(1,1,3,1), more=TRUE)
print(pred_plot_prec, split=c(2,1,3,1), more=TRUE)
print(pred_plot_recall, split=c(3,1,3,1), more=FALSE)
hexplot <- hexbinplot(accuracy_t ~ log10(file.size) | index.type + chunks,
aspect=2/3, data=dat, colorkey=FALSE)
hexplot <- useOuterStrips(hexplot)
print(hexplot)
hexbin_to_poly <- function(hx){
# Function to return a base graphics polygon() representation of
# the hexbin output
# Get centres
xy <- hcell2xy(hx)
# Calculate the dx and dy for hexcoords
sx <- hx@xbins/diff(hx@xbnds)
sy <- (hx@xbins * hx@shape)/diff(hx@ybnds)
inner <- 0.5
outer <- (2 * inner)/sqrt(3)
dx <- inner/sx
dy <- outer/(2 * sy)
# generate the polygons and offset to each centre
hexC <- hexcoords(dx, dy, n=length(xy$x), sep=NA)
hexC$x <- hexC$x + rep(xy$x, each=7)
hexC$y <- hexC$y + rep(xy$y, each=7)
return(hexC)
}
options(repr.plot.width = 6, repr.plot.height = 8)
# Create a 4 by 2 layout of edge to edge plots with
# an outer margin for annotation
par(mfcol=c(4,2), mar=c(0,0,0,0), oma=c(4,4,2.2,2.2), mgp=c(1.8,0.6, 0))
# Loop combinations of index type (columns) and chunking (rows)
for (it in 1:2){
for (ch in 1:4){
this_it <- levels(dat$index.type)[it]
this_ch <- levels(dat$chunks)[ch]
# Get a hexbin object for this panel subset
dd <- subset(dat, index.type == this_it & chunks == this_ch)
hx <- hexbin(log10(dd$file.size), dd$accuracy_t, xbins=30,
shape=2/3, xbnds=c(0,2), ybnds=c(0.2,1))
# Convert the hexbin of the data to base graphics
hx_p <- hexbin_to_poly(hx)
plot(hx_p, type='n', xaxt='n', yaxt='n', xlim=c(0,2), ylim=c(0.2,1))
# Colour scale for density (relative within plots)
cols <- (1 - (hx@count / max(hx@count)) * 0.7) - 0.2
# Add polygons
polygon(hx_p, col=grey(cols), border=NA)
# Add prediction lines for the four frame size fits
for (fs in 1:4){
this_fs <- levels(dat$frame.size)[fs]
fit <- subset(pred, index.type == this_it & chunks == this_ch & frame.size == this_fs)
lines(fit_acc ~ log10(file.size), data=fit, col=fs)
}
# Conditional panel annotation.
if (it == 1) axis(2, at=seq(0.25, 1, by=0.25))
if (ch == 4) axis(1)
if (ch == 1) {
axis(3, labels=FALSE, at=seq(0.25, 1, by=0.25))
mtext(side=3, this_it, line=1)
}
if (it == 2){
axis(4, labels=FALSE)
mtext(side=4, this_ch, line=1)
}
}
}
# Final labels.
legend('bottomright', col=1:4, legend=c("20 min", "10 min", "5 min", "2.5 min"),
bty='n', lty=1)
mtext(side=2, 'Accuracy', outer=TRUE, line=2.2)
mtext(side=1, expression(log[10]~file~size), outer=TRUE, line=2.2)
hexplot <- hexbinplot(precision_t ~ log10(file.size) | index.type + chunks,
aspect=2/3, data=dat, colorkey=FALSE)
hexplot <- useOuterStrips(hexplot)
print(hexplot)
options(repr.plot.width = 6, repr.plot.height = 8)
# Create a 4 by 2 layout of edge to edge plots with
# an outer margin for annotation
par(mfcol=c(4,2), mar=c(0,0,0,0), oma=c(4,4,2.2,2.2), mgp=c(1.8,0.6, 0))
# Loop combinations of index type (columns) and chunking (rows)
for (it in 1:2){
for (ch in 1:4){
this_it <- levels(dat$index.type)[it]
this_ch <- levels(dat$chunks)[ch]
# Get a hexbin object for this panel subset
dd <- subset(dat, index.type == this_it & chunks == this_ch)
hx <- hexbin(log10(dd$file.size), dd$precision_t, xbins=30,
shape=2/3, xbnds=c(0,2), ybnds=c(0.2,1))
# Convert the hexbin of the data to base graphics
hx_p <- hexbin_to_poly(hx)
plot(hx_p, type='n', xaxt='n', yaxt='n', xlim=c(0,2), ylim=c(0.2,1))
# Colour scale for density (relative within plots)
cols <- (1 - (hx@count / max(hx@count)) * 0.7) - 0.2
# Add polygons
polygon(hx_p, col=grey(cols), border=NA)
# Add prediction lines for the four frame size fits
for (fs in 1:4){
this_fs <- levels(dat$frame.size)[fs]
fit <- subset(pred, index.type == this_it & chunks == this_ch & frame.size == this_fs)
lines(prec_fit ~ log10(file.size), data=fit, col=fs)
}
# Conditional panel annotation.
if (it == 1) axis(2, at=seq(0.25, 1, by=0.25))
if (ch == 4) axis(1)
if (ch == 1) {
axis(3, labels=FALSE, at=seq(0.25, 1, by=0.25))
mtext(side=3, this_it, line=1)
}
if (it == 2){
axis(4, labels=FALSE)
mtext(side=4, this_ch, line=1)
}
}
}
range(y)
range(dd$precision_t)
hx <- hexbin(log10(dd$file.size), dd$precision_t, xbins=30,
shape=2/3, xbnds=c(0,2), ybnds=c(0.15,1))
hexplot <- hexbinplot(precision_t ~ log10(file.size) | index.type + chunks,
aspect=2/3, data=dat, colorkey=FALSE)
hexplot <- useOuterStrips(hexplot)
print(hexplot)
options(repr.plot.width = 6, repr.plot.height = 8)
# Create a 4 by 2 layout of edge to edge plots with
# an outer margin for annotation
par(mfcol=c(4,2), mar=c(0,0,0,0), oma=c(4,4,2.2,2.2), mgp=c(1.8,0.6, 0))
# Loop combinations of index type (columns) and chunking (rows)
for (it in 1:2){
for (ch in 1:4){
this_it <- levels(dat$index.type)[it]
this_ch <- levels(dat$chunks)[ch]
# Get a hexbin object for this panel subset
dd <- subset(dat, index.type == this_it & chunks == this_ch)
hx <- hexbin(log10(dd$file.size), dd$precision_t, xbins=30,
shape=2/3, xbnds=c(0,2), ybnds=c(0.15,1))
# Convert the hexbin of the data to base graphics
hx_p <- hexbin_to_poly(hx)
plot(hx_p, type='n', xaxt='n', yaxt='n', xlim=c(0,2), ylim=c(0.2,1))
# Colour scale for density (relative within plots)
cols <- (1 - (hx@count / max(hx@count)) * 0.7) - 0.2
# Add polygons
polygon(hx_p, col=grey(cols), border=NA)
# Add prediction lines for the four frame size fits
for (fs in 1:4){
this_fs <- levels(dat$frame.size)[fs]
fit <- subset(pred, index.type == this_it & chunks == this_ch & frame.size == this_fs)
lines(prec_fit ~ log10(file.size), data=fit, col=fs)
}
# Conditional panel annotation.
if (it == 1) axis(2, at=seq(0.25, 1, by=0.25))
if (ch == 4) axis(1)
if (ch == 1) {
axis(3, labels=FALSE, at=seq(0.25, 1, by=0.25))
mtext(side=3, this_it, line=1)
}
if (it == 2){
axis(4, labels=FALSE)
mtext(side=4, this_ch, line=1)
}
}
}
# Final labels.
legend('bottomright', col=1:4, legend=c("20 min", "10 min", "5 min", "2.5 min"),
bty='n', lty=1)
mtext(side=2, 'Precision', outer=TRUE, line=2.2)
mtext(side=1, expression(log[10]~file~size), outer=TRUE, line=2.2)
hexplot <- hexbinplot(precision_t ~ log10(file.size) | index.type + chunks,
aspect=2/3, data=dat, colorkey=FALSE)
hexplot <- useOuterStrips(hexplot)
print(hexplot)
options(repr.plot.width = 6, repr.plot.height = 8)
range(dd$recall_t)
hexplot <- hexbinplot(recall_t ~ log10(file.size) | index.type + chunks,
aspect=2/3, data=dat, colorkey=FALSE)
hexplot <- useOuterStrips(hexplot)
print(hexplot)
options(repr.plot.width = 6, repr.plot.height = 8)
# Create a 4 by 2 layout of edge to edge plots with
# an outer margin for annotation
par(mfcol=c(4,2), mar=c(0,0,0,0), oma=c(4,4,2.2,2.2), mgp=c(1.8,0.6, 0))
# Loop combinations of index type (columns) and chunking (rows)
for (it in 1:2){
for (ch in 1:4){
this_it <- levels(dat$index.type)[it]
this_ch <- levels(dat$chunks)[ch]
# Get a hexbin object for this panel subset
dd <- subset(dat, index.type == this_it & chunks == this_ch)
hx <- hexbin(log10(dd$file.size), dd$recall_t, xbins=30,
shape=2/3, xbnds=c(0,2), ybnds=c(0.15,1))
# Convert the hexbin of the data to base graphics
hx_p <- hexbin_to_poly(hx)
plot(hx_p, type='n', xaxt='n', yaxt='n', xlim=c(0,2), ylim=c(0.2,1))
# Colour scale for density (relative within plots)
cols <- (1 - (hx@count / max(hx@count)) * 0.7) - 0.2
# Add polygons
polygon(hx_p, col=grey(cols), border=NA)
# Add prediction lines for the four frame size fits
for (fs in 1:4){
this_fs <- levels(dat$frame.size)[fs]
fit <- subset(pred, index.type == this_it & chunks == this_ch & frame.size == this_fs)
lines(prec_fit ~ log10(file.size), data=fit, col=fs)
}
# Conditional panel annotation.
if (it == 1) axis(2, at=seq(0.25, 1, by=0.25))
if (ch == 4) axis(1)
if (ch == 1) {
axis(3, labels=FALSE, at=seq(0.25, 1, by=0.25))
mtext(side=3, this_it, line=1)
}
if (it == 2){
axis(4, labels=FALSE)
mtext(side=4, this_ch, line=1)
}
}
}
# Loop combinations of index type (columns) and chunking (rows)
for (it in 1:2){
for (ch in 1:4){
this_it <- levels(dat$index.type)[it]
this_ch <- levels(dat$chunks)[ch]
# Get a hexbin object for this panel subset
dd <- subset(dat, index.type == this_it & chunks == this_ch)
hx <- hexbin(log10(dd$file.size), dd$recall_t, xbins=30,
shape=2/3, xbnds=c(0,2), ybnds=c(0.15,1))
# Convert the hexbin of the data to base graphics
hx_p <- hexbin_to_poly(hx)
plot(hx_p, type='n', xaxt='n', yaxt='n', xlim=c(0,2), ylim=c(0.2,1))
# Colour scale for density (relative within plots)
cols <- (1 - (hx@count / max(hx@count)) * 0.7) - 0.2
# Add polygons
polygon(hx_p, col=grey(cols), border=NA)
# Add prediction lines for the four frame size fits
for (fs in 1:4){
this_fs <- levels(dat$frame.size)[fs]
fit <- subset(pred, index.type == this_it & chunks == this_ch & frame.size == this_fs)
lines(recall_fit ~ log10(file.size), data=fit, col=fs)
}
# Conditional panel annotation.
if (it == 1) axis(2, at=seq(0.25, 1, by=0.25))
if (ch == 4) axis(1)
if (ch == 1) {
axis(3, labels=FALSE, at=seq(0.25, 1, by=0.25))
mtext(side=3, this_it, line=1)
}
if (it == 2){
axis(4, labels=FALSE)
mtext(side=4, this_ch, line=1)
}
}
}
# Final labels.
legend('bottomright', col=1:4, legend=c("20 min", "10 min", "5 min", "2.5 min"),
bty='n', lty=1)
mtext(side=2, 'Recall', outer=TRUE, line=2.2)
mtext(side=1, expression(log[10]~file~size), outer=TRUE, line=2.2)
